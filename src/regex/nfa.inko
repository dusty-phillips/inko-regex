import std::fmt::(Format, Formatter, fmt)
import std::cmp::(Equal)
import std::stdio::(STDOUT)

# Based on https://deniskyashif.com/2019/02/17/implementing-a-regular-expression-engine/


# State is basically a container for transitions so we can replace
# states with new transitions while constructing an NFA.
class pub State {
  # The owned next transition(s) this state is currently wrapping.
  let @transition: Transition
  # Mark to avoid cycles when transitioning states
  let @mark_for_cycle_detection: Bool


  # Construct a new state, wrapping the provided transition
  fn static new(transition: Transition) -> State {
    State {
      @transition = transition,
      @mark_for_cycle_detection = false
    }
  }

  # Construct a new state wrapping a new End transition
  fn pub static end() -> State {
    State {
      @transition = Transition.End,
      @mark_for_cycle_detection = false
    }
  }

  # Check whether or not this is an end state
  fn pub end?() -> Bool {
    match @transition {
      case End -> true
      case _ -> false
    }
  }

  # Replace the contained transition with a new one
  fn mut replace(new_transition: Transition) -> Transition {
    @transition := new_transition
  }

  # Clear cycle detection marks recursively, starting at this state.
  #
  # Only warks marks until an uncleared mark is detected.
  fn mut clear_cycle_detection_marks() {
    if (@mark_for_cycle_detection) {
      @mark_for_cycle_detection = false
      match @transition {
        case End -> nil
        case Reference(_) -> nil
        case Symbol(string, state) -> state.clear_cycle_detection_marks
        case Empty(state) -> state.clear_cycle_detection_marks
        case Split(Empty(state1), Empty(state2)) -> {
          state1.clear_cycle_detection_marks
          state2.clear_cycle_detection_marks
        }
        case Split(Reference(_), Empty(state)) -> state.clear_cycle_detection_marks
        case Split(_, _) -> panic("Unexpected split encountered during clear_cycle_detection_marks")
      }
    }
  }

  # After calling this, next_states_collector will contain refs to all States that are accessible
  # from this state via either:
  # * A symbol transition with the given symbol
  # * A End state
  # by skipping over any empty, reference, or split transitions in the middle
  #
  # A side effect of this function is that it marks states for cycle detection.
  # You must call clear_cycle_detection_marks before calling it again with a new symbol.
  fn mut skip_to_symbol_transitions(char: String, next_states_collector: mut Array[ref State]) {
    if (@mark_for_cycle_detection) {
      return
    }
    @mark_for_cycle_detection = true

    match @transition {
      case End -> next_states_collector.push(self)
      case Symbol(character_to_match, state) if character_to_match == char -> next_states_collector.push(state)
      case Symbol(_, _) -> nil
      case Reference(state) -> state.skip_to_symbol_transitions(char, next_states_collector)
      case Empty(state) -> state.skip_to_symbol_transitions(char, next_states_collector)
      case Split(Empty(state1), Empty(state2)) -> {
        state1.skip_to_symbol_transitions(char, next_states_collector)
        state2.skip_to_symbol_transitions(char, next_states_collector)
      }
      case Split(Reference(state1), Empty(state2)) -> {
        state1.skip_to_symbol_transitions(char, next_states_collector)
        state2.skip_to_symbol_transitions(char, next_states_collector)
      }
      case Split(_, _) -> panic("Unexpected split encountered during skip_to_symbol_transitions")
    }
  }
}

impl Equal[State] for State {
  fn pub ==(other: ref State) -> Bool {
    match (self, other) {
      case ({@transition=transition}, {@transition=other_transition}) -> transition == other_transition
    }
  }
}

impl Format for State {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("()")
    @transition.fmt(formatter)
  }
}


# ADT for the various kinds of transitions a state can model.
class pub enum Transition {
  # The state containing this transition is an accepting End state with no further transitions
  case End
  # Transition to a new state if the given (single) character matches the one in the pattern
  case Symbol(String, State)
  # Transition to the next (owned) state without advancing a character (epsilon transition)
  case Empty(State)
  # Transition to the next (reference) state without advancing a character (epsilon transition)
  case Reference(mut State)
  # Store up to two transitions. In practice, these will both be epsilon transitions.
  case Split(Transition, Transition)
}

impl Equal[Transition] for Transition {
  fn pub ==(other: ref Transition) -> Bool {
    match (self, other) {
      case (End, End) -> true
      case (Symbol(char, state), Symbol(other_char, other_state)) -> char == other_char and state == other_state
      case (Empty(state), Empty(other_state)) -> state == other_state
      case (Reference(state), Reference(other_state)) -> state == other_state
      case(Split(t1, t2), Split(other_t1, other_t2)) -> t1 == other_t1 and t2 == other_t2
      case (_, _) -> false
    }
  }
}

impl Format for Transition {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case End -> {
        formatter.write("--->(End)")
      }
      case Symbol(string, state) -> {
        formatter.write("-{string}->\n")
        state.fmt(formatter)
      }
      case Empty(state) -> {
        formatter.write("-ε->\n")
        state.fmt(formatter)
      }
      case Reference(state) -> {
        formatter.write("--->(REF)\n")
      }
      case Split(t1, t2) -> {
        t1.fmt(formatter)
        formatter.write("\n  ")
        t2.fmt(formatter)
      }
    }
  }
}

# Represent a Non-deterministic finite state automaton for a regular expression.
#
# We only need to store the start state and a reference to the end state. This
# is enough for the various transition types to merge NFA's based on the various
# induction rules of (basic) regular expressions.
class pub Nfa {
  let @end: mut State
  let @start: State

  # Construct a new, empty NFA comprised of a start state with an epsilon transition
  # to an empty state. S -ε-> E
  fn pub static empty() -> Nfa {
    let end = State.end
    let end_ref = mut end
    let start = State.new(Transition.Empty(end))

    Nfa {
      @end = end_ref,
      @start = start
    }
  }

  # Construct a new symbol NFA, comprised of a start state with a symbol transition
  # to an end state.
  #
  # S -a-> E
  fn pub static symbol(char: String) -> Nfa {
    let end = State.end
    let end_ref = mut end
    let start = State.new(Transition.Symbol(char, end))

    Nfa {
      @end = end_ref,
      @start = start
    }
  }

  # Concatenate the provided NFA to ourselves. (AND expression)
  fn pub mut concat(other: Nfa) {
    match other {
      case {@end=other_end, @start=other_start} -> {
        @end.replace(Transition.Empty(other_start))
        @end = other_end
      }
    }
  }

  # Union the provided NFA with ourselves. (OR expression)
  fn pub mut union(other: Nfa) {
    match other {
      case {@end=other_end, @start=other_start} -> {
        # Temporarily place new_end in start
        let old_start = State.new(@start.replace(Transition.End))
        let new_end = State.new(@start.replace(Transition.Split(Transition.Empty(old_start), Transition.Empty(other_start))))
        let new_end_ref = mut new_end
        @end.replace(Transition.Reference(new_end_ref))
        other_end.replace(Transition.Empty(new_end))
        @end = new_end_ref

      }
    }
  }

  # Turn the current NFA into one that can be matched zero or more times
  fn pub mut zero_or_more() {
    let old_start = State.new(@start.replace(Transition.End))
    let new_end = State.end
    let old_start_ref = mut old_start
    @start.replace(Transition.Split(Transition.Reference(mut new_end), Transition.Empty(old_start)))
    @end.replace(Transition.Split(Transition.Reference(old_start_ref), Transition.Empty(new_end)))
  }

  # Turn the current NFA into one that can be matched one or more times
  fn pub mut one_or_more() {
    let old_start = State.new(@start.replace(Transition.End))
    let old_start_ref = mut old_start
    let new_end = State.new(@start.replace(Transition.Empty(old_start)))
    @end.replace(Transition.Split(Transition.Reference(old_start_ref), Transition.Empty(new_end)))
  }

  # Turn the current NFA into one that can be matched zero or one times
  fn pub mut zero_or_one() {
    let old_start = State.new(@start.replace(Transition.End))
    @start.replace(Transition.Split(Transition.Reference(@end), Transition.Empty(old_start)))
  }

  # Return true if the provided word matches the regular expression encoded in this NFA.
  #
  # Currently, match is defined as "an end state is reached starting from the currennt state".
  # Specifically, it is possible for a match to return true even if not all characetrs in the
  # provided word have been matched.
  fn pub mut match(word: String) -> Bool {
    let mut current_states = [mut @start]
    let characters = word.characters
    let mut character_option = characters.next
    while (character_option).some? {
      let character = character_option.unwrap
      let mut next_states: Array[mut State] = []
      current_states.iter_mut.each fn (state) {
        state.skip_to_symbol_transitions(character, next_states)
        state.clear_cycle_detection_marks
      }
      current_states = next_states
      character_option = characters.next
    }

    let match_found = current_states.iter.find fn (state) {state.end?}
    match_found.some?
  }
}

impl Equal[Nfa] for Nfa {
  fn pub ==(other: ref Nfa) -> Bool {
    match (self, other) {
      case ({@end=end, @start=start}, {@end=other_end, @start=other_start}) -> {
        end == other_end and start == other_start
      }
    }
  }
}

impl Format for Nfa {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("Nfa \{\n")
    self.start.fmt(formatter)
    formatter.write("\n}")
  }
}
