import std::fmt::(Format, Formatter, fmt)
import std::cmp::(Equal)
import std::stdio::(STDOUT)

# Based on https://deniskyashif.com/2019/02/17/implementing-a-regular-expression-engine/

class pub State {
  let @transition: Transition
  let @mark_for_cycle_detection: Bool


  fn static new(transition: Transition) -> State {
    State {
      @transition = transition,
      @mark_for_cycle_detection = false
    }
  }

  fn pub static end() -> State {
    State {
      @transition = Transition.End,
      @mark_for_cycle_detection = false
    }
  }

  fn pub end?() -> Bool {
    match @transition {
      case End -> true
      case _ -> false
    }
  }

  fn mut replace(new_transition: Transition) -> Transition {
    @transition := new_transition
  }

  fn mut clear_cycle_detection_marks() {
    if (@mark_for_cycle_detection) {
      @mark_for_cycle_detection = false
      match @transition {
        case End -> nil
        case Reference(_) -> nil
        case Symbol(string, state) -> state.clear_cycle_detection_marks
        case Empty(state) -> state.clear_cycle_detection_marks
        case Split(Empty(state1), Empty(state2)) -> {
          state1.clear_cycle_detection_marks
          state2.clear_cycle_detection_marks
        }
        case Split(Reference(_), Empty(state)) -> state.clear_cycle_detection_marks
        case Split(_, _) -> panic("Unexpected split encountered during clear_cycle_detection_marks")
      }
    }
  }

  # After calling this, next_states_collector will contain refs to all States that are accessible
  # from this state via either:
  # * A symbol transition with the given symbol
  # * A End state
  # by skipping over any empty, reference, or split transitions in the middle
  #
  # A side effect of this function is that it marks states for cycle detection.
  # You must call clear_cycle_detection_marks before calling it again with a new symbol.
  fn mut skip_to_symbol_transitions(char: String, next_states_collector: mut Array[ref State]) {
    if (@mark_for_cycle_detection) {
      return
    }
    @mark_for_cycle_detection = true

    match @transition {
      case End -> next_states_collector.push(self)
      case Symbol(character_to_match, state) if character_to_match == char -> next_states_collector.push(state)
      case Symbol(_, _) -> nil
      case Reference(state) -> state.skip_to_symbol_transitions(char, next_states_collector)
      case Empty(state) -> state.skip_to_symbol_transitions(char, next_states_collector)
      case Split(Empty(state1), Empty(state2)) -> {
        state1.skip_to_symbol_transitions(char, next_states_collector)
        state2.skip_to_symbol_transitions(char, next_states_collector)
      }
      case Split(Reference(state1), Empty(state2)) -> {
        state1.skip_to_symbol_transitions(char, next_states_collector)
        state2.skip_to_symbol_transitions(char, next_states_collector)
      }
      case Split(_, _) -> panic("Unexpected split encountered during skip_to_symbol_transitions")
    }
  }
}

impl Equal[State] for State {
  fn pub ==(other: ref State) -> Bool {
    match (self, other) {
      case ({@transition=transition}, {@transition=other_transition}) -> transition == other_transition
    }
  }
}

impl Format for State {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("()")
    @transition.fmt(formatter)
  }
}

class pub enum Transition {
  case End
  case Symbol(String, State)
  case Empty(State)
  case Reference(mut State)
  case Split(Transition, Transition)
}

impl Equal[Transition] for Transition {
  fn pub ==(other: ref Transition) -> Bool {
    match (self, other) {
      case (End, End) -> true
      case (Symbol(char, state), Symbol(other_char, other_state)) -> char == other_char and state == other_state
      case (Empty(state), Empty(other_state)) -> state == other_state
      case (Reference(state), Reference(other_state)) -> state == other_state
      case(Split(t1, t2), Split(other_t1, other_t2)) -> t1 == other_t1 and t2 == other_t2
      case (_, _) -> false
    }
  }
}

impl Format for Transition {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case End -> {
        formatter.write("--->(End)")
      }
      case Symbol(string, state) -> {
        formatter.write("-{string}->\n")
        state.fmt(formatter)
      }
      case Empty(state) -> {
        formatter.write("-Îµ->\n")
        state.fmt(formatter)
      }
      case Reference(state) -> {
        formatter.write("--->(REF)\n")
      }
      case Split(t1, t2) -> {
        t1.fmt(formatter)
        formatter.write("\n  ")
        t2.fmt(formatter)
      }
    }
  }
}

class pub Nfa {
  let @end: mut State
  let @start: State

  fn static new(start: State, end: mut State) -> Nfa {
    Nfa {
      @start=start,
      @end=end
    }
  }

  fn pub static empty() -> Nfa {
    let end = State.end
    let end_ref = mut end
    let start = State.new(Transition.Empty(end))

    Nfa {
      @end = end_ref,
      @start = start
    }
  }

  fn pub static symbol(char: String) -> Nfa {
    let end = State.end
    let end_ref = mut end
    let start = State.new(Transition.Symbol(char, end))

    Nfa {
      @end = end_ref,
      @start = start
    }
  }

  fn pub mut concat(other: Nfa) {
    match other {
      case {@end=other_end, @start=other_start} -> {
        @end.replace(Transition.Empty(other_start))
        @end = other_end
      }
    }
  }

  fn pub mut union(other: Nfa) {
    match other {
      case {@end=other_end, @start=other_start} -> {
        # Temporarily place new_end in start
        let old_start = State.new(@start.replace(Transition.End))
        let new_end = State.new(@start.replace(Transition.Split(Transition.Empty(old_start), Transition.Empty(other_start))))
        let new_end_ref = mut new_end
        @end.replace(Transition.Reference(new_end_ref))
        other_end.replace(Transition.Empty(new_end))
        @end = new_end_ref

      }
    }
  }

  fn pub mut zero_or_more() {
    let old_start = State.new(@start.replace(Transition.End))
    let new_end = State.end
    let old_start_ref = mut old_start
    @start.replace(Transition.Split(Transition.Reference(mut new_end), Transition.Empty(old_start)))
    @end.replace(Transition.Split(Transition.Reference(old_start_ref), Transition.Empty(new_end)))
  }

  fn pub mut one_or_more() {
    let old_start = State.new(@start.replace(Transition.End))
    let old_start_ref = mut old_start
    let new_end = State.new(@start.replace(Transition.Empty(old_start)))
    @end.replace(Transition.Split(Transition.Reference(old_start_ref), Transition.Empty(new_end)))
  }

  fn pub mut zero_or_one() {
    let old_start = State.new(@start.replace(Transition.End))
    @start.replace(Transition.Split(Transition.Reference(@end), Transition.Empty(old_start)))
  }

  fn pub mut match(word: String) -> Bool {
    let mut current_states = [mut @start]
    let characters = word.characters
    let mut character_option = characters.next
    while (character_option).some? {
      let character = character_option.unwrap
      let mut next_states: Array[mut State] = []
      current_states.iter_mut.each fn (state) {
        state.skip_to_symbol_transitions(character, next_states)
        state.clear_cycle_detection_marks
      }
      current_states = next_states
      character_option = characters.next
    }

    let match_found = current_states.iter.find fn (state) {state.end?}
    match_found.some?
  }
}

impl Equal[Nfa] for Nfa {
  fn pub ==(other: ref Nfa) -> Bool {
    match (self, other) {
      case ({@end=end, @start=start}, {@end=other_end, @start=other_start}) -> {
        end == other_end and start == other_start
      }
    }
  }
}

impl Format for Nfa {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("Nfa \{\n")
    self.start.fmt(formatter)
    formatter.write("\n}")
  }
}
