import std::fmt::(Format, Formatter, fmt)
import std::cmp::(Equal)
import std::stdio::(STDOUT)

# Based on https://deniskyashif.com/2019/02/17/implementing-a-regular-expression-engine/

class pub State {
  let @transition: Transition


  fn static new(transition: Transition) -> State {
    State {
      @transition = transition
    }
  }

  fn pub static end() -> State {
    State {
      @transition = Transition.End
    }
  }

  fn mut replace(new_transition: Transition) -> Transition {
    @transition := new_transition
  }
}

impl Equal[State] for State {
  fn pub ==(other: ref State) -> Bool {
    match (self, other) {
      case ({@transition=transition}, {@transition=other_transition}) -> transition == other_transition
    }
  }
}

impl Format for State {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("()")
    @transition.fmt(formatter)
  }
}

class pub enum Transition {
  case End
  case Symbol(String, State)
  case Empty(State)
  case Reference(ref State)
  case Split(Transition, Transition)
}

impl Equal[Transition] for Transition {
  fn pub ==(other: ref Transition) -> Bool {
    match (self, other) {
      case (End, End) -> true
      case (Symbol(char, state), Symbol(other_char, other_state)) -> char == other_char and state == other_state
      case (Empty(state), Empty(other_state)) -> state == other_state
      case (Reference(state), Reference(other_state)) -> state == other_state
      case(Split(t1, t2), Split(other_t1, other_t2)) -> t1 == other_t1 and t2 == other_t2
      case (_, _) -> false
    }
  }
}

impl Format for Transition {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case End -> {
        formatter.write("--->(End)")
      }
      case Symbol(string, state) -> {
        formatter.write("-{string}->\n")
        state.fmt(formatter)
      }
      case Empty(state) -> {
        formatter.write("-Îµ->\n")
        state.fmt(formatter)
      }
      case Reference(state) -> {
        formatter.write("--->(REF)\n")
      }
      case Split(t1, t2) -> {
        t1.fmt(formatter)
        formatter.write("\n  ")
        t2.fmt(formatter)
      }
    }
  }
}

class pub Nfa {
  let @end: mut State
  let @start: State

  fn static new(start: State, end: mut State) -> Nfa {
    Nfa {
      @start=start
      @end=end
    }
  }

  fn pub static empty() -> Nfa {
    let end = State.end
    let end_ref = mut end
    let start = State.new(Transition.Empty(end))

    Nfa {
      @end = end_ref
      @start = start
    }
  }

  fn pub static symbol(char: String) -> Nfa {
    let end = State.end
    let end_ref = mut end
    let start = State.new(Transition.Symbol(char, end))

    Nfa {
      @end = end_ref
      @start = start
    }
  }

  fn pub mut concat(other: Nfa) {
    match other {
      case {@end=other_end, @start=other_start} -> {
        @end.replace(Transition.Empty(other_start))
        @end = other_end
      }
    }
  }

  fn pub mut union(other: Nfa) {
    match other {
      case {@end=other_end, @start=other_start} -> {
        # Temporarily place new_end in start
        let old_start = State.new(@start.replace(Transition.End))
        let new_end = State.new(@start.replace(Transition.Split(Transition.Empty(old_start), Transition.Empty(other_start))))
        let new_end_ref = mut new_end
        @end.replace(Transition.Reference(new_end_ref))
        other_end.replace(Transition.Empty(new_end))
        @end = new_end_ref

      }
    }
  }

  fn pub mut zero_or_more() {
    let old_start = State.new(@start.replace(Transition.End))
    let new_end = State.end
    let old_start_ref = ref old_start
    @start.replace(Transition.Split(Transition.Reference(ref new_end), Transition.Empty(old_start)))
    @end.replace(Transition.Split(Transition.Reference(old_start_ref), Transition.Empty(new_end)))
  }

  fn pub mut one_or_more() {
    let old_start = State.new(@start.replace(Transition.End))
    let old_start_ref = mut old_start
    let new_end = State.new(@start.replace(Transition.Empty(old_start)))
    @end.replace(Transition.Split(Transition.Reference(old_start_ref), Transition.Empty(new_end)))
  }

  fn pub mut zero_or_one() {
    let old_start = State.new(@start.replace(Transition.End))
    @start.replace(Transition.Split(Transition.Reference(@end), Transition.Empty(old_start)))
  }
}

impl Equal[Nfa] for Nfa {
  fn pub ==(other: ref Nfa) -> Bool {
    match (self, other) {
      case ({@end=end, @start=start}, {@end=other_end, @start=other_start}) -> {
        end == other_end and start == other_start
      }
    }
  }
}

impl Format for Nfa {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("Nfa \{\n")
    self.start.fmt(formatter)
    formatter.write("\n}")
  }
}
