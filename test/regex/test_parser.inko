
import std::stdio::(STDOUT)
import std::fmt::(fmt)
import std::test::Tests
import regex::parser::(TreeNode, Parser)
import regex::nfa::(Nfa, State, Transition)

fn pub tests(t: mut Tests) {
  t.test("Parse a single character") fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.SingleTerm(
        TreeNode.SingleFactor(
          TreeNode.CharacterAtom(
            TreeNode.Character('a')
          )
        )
      )
    )

    let parser = Parser.new('a')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('b'), false)
  }

  t.test("Parse two character concatenation") fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.ConcatTerm(
        TreeNode.SingleFactor(
          TreeNode.CharacterAtom(
            TreeNode.Character('a')
          )
        ),
        TreeNode.SingleTerm(
          TreeNode.SingleFactor(
            TreeNode.CharacterAtom(
              TreeNode.Character('b')
            )
          )
        )
      )
    )

    let parser = Parser.new('ab')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('ab'), true)
    t.equal(nfa.match('zz'), false)


  }

  t.test("Parse a union of two characters") fn (t) {
    let expected = TreeNode.UnionExpression(
      TreeNode.SingleTerm(
        TreeNode.SingleFactor(
          TreeNode.CharacterAtom(
            TreeNode.Character('a')
          )
        )
      ),
      TreeNode.SingleExpression(
        TreeNode.SingleTerm(
          TreeNode.SingleFactor(
            TreeNode.CharacterAtom(
              TreeNode.Character('b')
            )
          )
        )
      )
    )
    let parser = Parser.new('a|b')
    let tree = parser.parse()
    t.equal(tree, expected)

    let expected = {
      let end = State.end
      let end_mut = mut end
      let start = State.new(Transition.Split(
        Transition.Empty(
          State.new(Transition.Symbol("a", State.new(Transition.Reference(end_mut))))
        ),
        Transition.Empty(
          State.new(Transition.Symbol("b", State.new(Transition.Empty(end))))
        )
      ))

      Nfa.new(start, end_mut)
    }

    let nfa = tree.to_nfa
    t.equal(nfa, expected)

    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('b'), true)
    t.equal(nfa.match('c'), false)
  }

  t.test("Parse a single character zero or more") fn (t) {
   let expected = TreeNode.SingleExpression(
    TreeNode.SingleTerm(
      TreeNode.ZeroOrMoreFactor(
        TreeNode.CharacterAtom(
          TreeNode.Character('a')
        )
      )
    )
   )

    let parser = Parser.new('a*')
    let tree = parser.parse()
    t.equal(tree, expected)


    let nfa = tree.to_nfa
    t.equal(nfa.match(''), true)
    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('aa'), true)
    t.equal(nfa.match('aaaaaaaaa'), true)
    t.equal(nfa.match('b'), true) # true because "zero a's" matches
  }


  t.test("Parse a single character zero or one") fn (t) {
   let expected = TreeNode.SingleExpression(
    TreeNode.SingleTerm(
      TreeNode.ZeroOrOneFactor(
        TreeNode.CharacterAtom(
          TreeNode.Character('a')
        )
      )
    )
   )

    let parser = Parser.new('a?')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    STDOUT.new.print(fmt(nfa))

    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('aa'), true)
    t.equal(nfa.match(''), true)
    t.equal(nfa.match('b'), true) # true because "zero a's" matches
  }

  t.test("Parse a single character one or more") fn (t) {
   let expected = TreeNode.SingleExpression(
    TreeNode.SingleTerm(
      TreeNode.OneOrMoreFactor(
        TreeNode.CharacterAtom(
          TreeNode.Character('a')
        )
      )
    )
   )

    let parser = Parser.new('a+')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match(''), false)
    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('aa'), true)
    t.equal(nfa.match('aaaa'), true)
    t.equal(nfa.match('b'), false)
  }

  t.test("Parse a single character grouping") fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.SingleTerm(
        TreeNode.SingleFactor(
          TreeNode.GroupedAtom(
            TreeNode.SingleExpression(
              TreeNode.SingleTerm(
                TreeNode.SingleFactor(
                  TreeNode.CharacterAtom(
                    TreeNode.Character('a')
                  )
                )
              )
            )
          )
        )
      )
    )

    let parser = Parser.new('(a)')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('a'), true)
    t.equal(nfa.match('b'), false)
  }

  t.test("Parse a multi character grouping") fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.SingleTerm(
        TreeNode.SingleFactor(
          TreeNode.GroupedAtom(
            TreeNode.SingleExpression(
              TreeNode.ConcatTerm(
                TreeNode.SingleFactor(
                  TreeNode.CharacterAtom(
                    TreeNode.Character('a')
                  )
                ),
                TreeNode.SingleTerm(
                  TreeNode.SingleFactor(
                    TreeNode.CharacterAtom(
                      TreeNode.Character('b')
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    let parser = Parser.new('(ab)')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('ab'), true)
    t.equal(nfa.match('bc'), false)
  }

  t.test('Parse a multi character grouping zero or one') fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.SingleTerm(
        TreeNode.ZeroOrOneFactor(
          TreeNode.GroupedAtom(
            TreeNode.SingleExpression(
              TreeNode.ConcatTerm(
                TreeNode.SingleFactor(
                  TreeNode.CharacterAtom(
                    TreeNode.Character('a')
                  )
                ),
                TreeNode.SingleTerm(
                  TreeNode.SingleFactor(
                    TreeNode.CharacterAtom(
                      TreeNode.Character('b')
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    let parser = Parser.new('(ab)?')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('ab'), true)
    t.equal(nfa.match(''), true)
  }


  t.test("Parse an escaped *") fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.SingleTerm(
        TreeNode.SingleFactor(
          TreeNode.CharacterAtom(
            TreeNode.EscapedCharacter('*')
          )
        )
      )
    )

    let parser = Parser.new('\*')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('*'), true)
    t.equal(nfa.match('\\'), false)
  }


  t.test("Parse an escaped +") fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.SingleTerm(
        TreeNode.SingleFactor(
          TreeNode.CharacterAtom(
            TreeNode.EscapedCharacter('+')
          )
        )
      )
    )

    let parser = Parser.new('\+')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('+'), true)
    t.equal(nfa.match('\\'), false)
  }


  t.test("Parse an escaped \\") fn (t) {
    let expected = TreeNode.SingleExpression(
      TreeNode.SingleTerm(
        TreeNode.SingleFactor(
          TreeNode.CharacterAtom(
            TreeNode.EscapedCharacter('\\')
          )
        )
      )
    )

    let parser = Parser.new('\\\\')
    let tree = parser.parse()
    t.equal(tree, expected)

    let nfa = tree.to_nfa

    t.equal(nfa.match('\\'), true)
    t.equal(nfa.match('*'), false)
  }
}
